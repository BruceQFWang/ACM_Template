对于最小点覆盖,每个点只有两种状态,即属于点覆盖或者不属于点覆盖:
1):dp[i][0]表示点 不i 属于点覆盖,并且以点 i 为根的子树中所连接的边都被覆盖的情况下点覆盖集中所包含最少点的个数.
2):dp[i][1]表示点 i 属于点覆盖,且以点 i 为根的子树中所连接的边都被覆盖的情况下点覆盖集中所包含最少点的个数.
对于第一种状态dp[i][0],要求所有与 i 连接的边都被覆盖,但是点 i 不属于点覆盖,那么点 i 的所有子节点就必须属于点覆盖,即对于点 i 的第二种状态与所有子节点的第一种状态有关,在数值上等于所有子节点第一种状态的和.DP转移方程如下:
dp[i][0] = ∑(v 取 i 的子节点)dp[v][1]
对于第二种状态dp[i][1],等于每个儿子节点的两种状态的最小值之和加1,DP转移方程如下:
dp[i][1] = 1 + ∑(v 取 i 的子节点)min(dp[v][0], dp[v][1])
代码：
int n, dp[N][2];
vector<int>E[N];

void dfs(int u, int pre){
    dp[u][0] = 0;
    dp[u][1] = 1;
    for(int i=0;i<E[u].size(); i++){
        int v = E[u][i];
        if(v == pre)continue;
        dfs(v, u);
        dp[u][0] += dp[v][1];
        dp[u][1] += min(dp[v][0], dp[v][1]);
    }
}

